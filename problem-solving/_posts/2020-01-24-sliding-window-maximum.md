---
layout: page
title:  움직이는 윈도우의 최대값 구하기
tags: [LeetCode, Deque]
---

배열 nums가 주어지고, 그 위에서 왼쪽에서 오른쪽으로 움직이는 길이 k의 윈도우가 있습니다.
윈도우를 오른쪽으로 한 칸씩 이동시키면서 각 윈도우의 k개 원소 중 최대값을 출력하는
문제입니다.

아래 풀이를 보기 전에 먼저 고민해보는 것을 권해드립니다.
<a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank">
(LeetCode 문제 바로가기)</a>


예시:
```
Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
Output: [3,3,5,5,6,7] 
Explanation: 

Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

### 문제정의
* 윈도우

주어진 Input의 연속된 부분배열이다.
길이가 k인 윈도우는 연속된 k개의 숫자로 이루어진 부분배열이다.

<img style="margin: 0 auto; width: 350px;"
src="/assets/img/2020-01-24-sliding-window-maximum-1.png" />


따라서 길이 k의 $$i$$번째 윈도우 $$w_i$$를 다음과 같이 정의한다.

$$w_i = \{a_i, a_{i+1}, a_{i+2}, ..., a_{i+k-1} \}$$



* 윈도우의 이동

윈도우의 이동은 윈도우 $$w$$의 인덱스 $$i$$가 증가하는 것으로 생각할 수 있다.
윈도우가 $$w_i$$에서 $$w_{i+1}$$로 이동하면, $$w_i$$의 가장 왼쪽 원소 $$a_i$$가
빠지고, 가장 오른쪽에 새 원소 $$a_{i+k}$$가 들어온다. 아래 그림은 $$w_3$$에서
$$w_4$$로 윈도우가 이동하는 예시를 보여준다.  

<img style="margin: 0 auto; width: 350px;"
src="/assets/img/2020-01-24-sliding-window-maximum-2.png" />



* 윈도우의 최대값

윈도우 $$w_i$$의 원소 중 최대값 $$m_i$$을 다음과 같이 정의한다. 
위 그림에서 윈도우 $$w_4$$의 최대값은 6이다.

$$
\begin{aligned}
m_i &= max(w_i) \\
    &= max(\{a_i, a_{i+1}, a_{i+2}, ..., a_{i+k-1} \})
\end{aligned}
$$

따라서 주어진 문제는 $$m_0, m_1, m_2, ..., m_{n-k+1}$$을 순서대로 출력하는 것과 
같다.


### 기본적인 방법
윈도우 이동에 따른 최대값 $$m$$의 변화를 생각해보자. 윈도우 $$w_i$$의 최대값 
$$m_i$$가 $$m_i \ne a_i$$라면, 즉, $$w_i$$의 최대값이 윈도우의 첫 번째 원소가 아닌경우, 
윈도우가 $$w_{i+1}$$로 이동하더라도 $$m_i$$는 윈도우 안에 존재하게 된다. 

<img style="margin: 0 auto; width: 350px;"
src="/assets/img/2020-01-24-sliding-window-maximum-3.png" />


정의에 따라 $$m_i$$는 $$w_{i+1}$$의 원소 중 새로 들어온 가장 마지막 원소 $$a_{i+k}$$를 제외한
모든 원소보다 여전히 크므로, 마지막 원소 $$a_{i+k}$$와 비교를 통해 $$w_{i+1}$$의
최대값 $$m_{i+1}$$을 결정할 수 있다.

<img style="margin: 0 auto; width: 350px;"
src="/assets/img/2020-01-24-sliding-window-maximum-4.png" />


반면, $$m_i$$가 첫 번째 원소 $$a_i$$라면 $$w_{i+1}$$에서는 더 이상 $$m_i$$가 존재하지 않기 때문에, $$w_{i+1}$$
모든 원소를 비교하여 $$m_{i+1}$$을 결정해야 한다.  

따라서 이 방법은 최악의 경우에 윈도우가 이동할 때마다 매번 k개의 원소를 비교해야
하므로 시간복잡도 $$O(n^2)$$를 갖는다.


### 개선된 방법
윈도우의 원소들을 일일이 비교하지 않고 최대값을 계산할 수는 없을까?
윈도우가 이동하면서 새로 들어오는 값에 따라 최대값이 결정되겠지만, 새로 
들어오는 원소의 값에 상관없이 절대 최대값이 될 수 없는 원소들이 있다.

임의의 윈도우 안에서, 

* 최대값 왼쪽의 원소는 이미 최대값보다 작다는 사실이 밝혀졌으므로 최대값이 될 수 없다.  
<figure>
  <img style="margin: 0 auto; width: 350px;" src="/assets/img/2020-01-24-sliding-window-maximum-5.png" />
  <figcaption>nums[3]은 최대값이 될 수 없다.</figcaption>
</figure>

위 그림에서 nums[3]이 최대값이 될 수 없다는 것은 자명하다.
윈도우가 이동하면 새로 들어오는 원소의 값과 무관하게 nums[3]은 최대값이 될 수 없다.

* 최대값 오른쪽에 있으나 자신의 오른쪽에 자신보다 큰 원소가 있는 경우 최대값이 될 수 없다.
<figure>
  <img style="margin: 0 auto; width: 350px;" src="/assets/img/2020-01-24-sliding-window-maximum-6.png" />
  <figcaption>nums[5]는 다음 윈도우에서도 자기보다 큰 수가 하나 이상 존재(nums[6])하므로 최대값이 될 수 없다.</figcaption>
</figure>

위 그림에서 nums[5]는 자신의 오른쪽에 있는 nums[6]보다 먼저 윈도우에서 벗어나게 
되는데, nums[6]이 더 큰 원소이므로 최대값이 될 수 없다. 즉, 오른쪽에 자신보다 더
큰 원소가 있는 원소는 그 원소보다 윈도우에서 먼저 벗어나게 되므로 최대값이 될 수 없다.

최대값이 될 수 ***있는*** 원소는 나머지의 경우이다. 임의의 윈도우 안에서,

* 최대값 오른쪽에 있으면서 자신의 오른쪽에 자신보다 작은 원소만 있는 경우

위 그림에서 nums[6]이 이 경우에 해당한다. 
자신의 왼쪽에 있는, 자신보다 큰 원소들이 차례대로 윈도우에서 빠져나가게 되면, 
언젠가는 최대값이 될 수 ***있다***. 만약 새로 들어오는 원소가 자신보다 큰 원소라면
앞서 설명한 최대값이 될 수 없는 두 번째 경우가 된다.

이렇게 윈도우의 이동에 따라 최대값이 될 수 ***있는*** 원소들을 알 수 있다면 우리는
이 후보 원소들과 새로운 원소만 고려하여 각 윈도우의 최대값을 구할 수 있다.


### 최대값이 될 수 있는 원소들의 저장과 업데이트

자료구조 덱(deque)를 이용하여 최대값이 될 수 있는 원소들을 윈도우마다 쉽게 
저장 및 업데이트 할 수 있다. 덱은 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료구조이다.

주어진 입력 배열을 차례대로 순회하면서 현재 윈도우에 해당하는 i번째 원소를 덱에 삽입하되,
아래의 절차를 따른다.

1. 덱의 0번째 원소가 현재 윈도우에 해당하지 않는다면 pop_front()한다.
2. 뒤에서부터 i번째 원소보다 작은 원소가 있으면 pop_back()한다.
3. 뒷부분에 i번째 원소를 push_back()한다.

3가지 절차를 통해, 현재 윈도우의 최대값이 될 수 있는 원소를 저장할 수 있으며, 
0번째 원소는 현재 윈도우의 최대값이 된다. 나머지 원소들은 다음 윈도우에서 최대값이
될 수 있는 원소들이다.

각 과정을 조금 더 자세히 살펴보도록 하자.

1. 윈도우가 한 칸씩 오른쪽으로 이동하면서, 윈도우에서 가장 왼쪽 원소가 다음 윈도우에서
벗어나게 된다. 3번 과정에 따라, 삽입된 원소는 항상 마지막 인덱스 위치하기 때문에
0번째 원소가 가장 먼저 들어온 원소이고 마지막 원소가 가장 늦게 들어온 원소가 된다.
따라서, 0번째 원소만 현재 윈도우에 해당하는지 검사하면 나머지 원소는 검사할 필요가 없다.    
2. 앞 부분에서 최대값이 될 수 ***없는*** 원소에 대해 설명하였다. 2번은 최대값이
될 수 ***없는*** 원소들을 제거하는 과정이다. i번째 원소보다 작은 원소는 윈도우 안에서
오른쪽에 자신보다 큰 원소 i가 있다는 것을 의미하기 때문에 최대값이 될 수 ***없다***.
3. 최대값이 될 수 ***있는*** 원소를 삽입하는 과정이다. i번째 원소보다 작은 원소는 2번
과정에서 모두 pop_back() 되었으므로, 덱에서 i번째 원소의 앞에는 i번째 원소보다
큰 원소만 남게된다(뒤에는 아직 삽입된 원소가 없다). 다음 윈도우로 이동할 때, 새로 들어오는
원소가 i번째 원소보다 작다면 i번째 원소는 덱에 남아있게 될 것이고, 뒤에는 자기보다 작은
i+1번째 원소가 있게 된다. 이런식으로 덱의 원소들은 내림차순으로 정렬이 되기 때문에
0번째 원소는 현재 윈도우에서 가장 큰 값, 즉, 최대값이 된다.


### 개선된 방법의 구현




