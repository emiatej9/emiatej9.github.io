---
layout: page
title:  Sliding Window Maximum
tags: [LeetCode, Deque]
---

주어진 배열 nums에 대해, 왼쪽에서 오른쪽으로 움직이는 크기 k의 윈도우가 있다.<br>
윈도우를 오른쪽으로 한 자리씩 이동하면서 윈도우에 포함되는 k개의 숫자 중 최대값을 출력하시오.  
<a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank">
    LeetCode 문제 바로가기
</a>


예시:
```
Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
Output: [3,3,5,5,6,7] 
Explanation: 

Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

## 풀이
---
### 문제정의

길이가 k인 윈도우는 연속된 k개의 숫자로 생각할 수 있다. 
따라서 i번째 윈도우($$w_i$$)를 다음과 같이 정의해보자.

$$w_i = \{a_i, a_{i+1}, a_{i+2}, ..., a_{i+k-1} \}$$

그리고 i번째 윈도우($$w_i$$)에서 가장 큰 수를 $$m_i$$ 라고 할 때,

$$
\begin{aligned}
m_i &= max(w_i) \\
    &= max(\{a_i, a_{i+1}, a_{i+2}, ..., a_{i+k-1} \})
\end{aligned}
$$

이다(시간복잡도 $$O(k)$$). 따라서 이 문제는 $$m_0, m_1, m_2, ..., m_{n-k+1}$$을 순서대로 출력하는 것과 같다.

### 기본적인 방법
이제 윈도우가 오른쪽으로 이동하는 것에 따른 최대값($$m$$) 계산을 생각해보자.
윈도우가 $$w_i$$에서 $$w_{i+1}$$로 이동하면, 가장 왼쪽에 위치한 $$a_i$$는 윈도우에서 벗어나게 되고
새로운 숫자 $$a_{i+k}$$가 윈도우의 오른쪽 맨 끝으로 들어오게 된다.

$$w_i$$에서 벗어나는 수 $$a_i$$가 $$a_i \ne m_i$$라면, 윈도우 $$w_{i+1}$$에도 여전히 $$m_i$$은 포함되므로,
새로 들어오는 값 $$a_{i+k}$$을 제외한 모든 수가 $$m_i$$보다 작다는 것을 이미 알고있다.
따라서 $$a_{i+k}$$와 비교하여 $$m_{i+1}$$을 결정하면 된다.
즉, $$m_{i+1}=max(m_i, a_{i+k})$$이다(시간복잡도 $$O(1)$$).

만약 $$m_i=a_i$$인 경우라면, 윈도우가 오른쪽으로 이동하면서 최대값이 사라지게 되므로
$$m_{i+1}=max(w_{i+1})$$을 다시 계산해야 한다.
기본적으로 $$m_{i+1}$$ 계산은 윈도우 내의 모든 k개의 숫자를 순회하며 일일이 비교해야하기 때문에
$$O(k)$$의 시간복잡도를 갖는다.

하지만 우리는 $$O(k)$$의 $$m_{i+1}$$ 계산 과정을 조금 더 최적화 할 수 있다.


### 윈도우 내 숫자 분류
조금 더 나은 방법을 설명하기에 앞서, 윈도우 $$w_i$$ 안의 숫자들을 다음 3가지로 분류해보자.

* $$m_i$$보다 왼쪽에 위치한 경우

윈도우가 오른쪽으로 이동하면서 $$m_i$$보다 먼저 윈도우에서 벗어나게 된다.
또한 $$m_i$$의 정의에 따라 $$m_i$$보다 작은 값을 갖기 때문에, 
$$w_i$$보다 오른쪽에 있는 윈도우에서도 *최대값이 될 수 없다*.

* $$m_i$$보다 오른쪽에 위치하고, 자신의 오른쪽에 자신보다 큰 수가 없는 경우 

$$m_i$$보다 나중에 윈도우에서 벗어나므로, 윈도우가 오른쪽으로 이동하면서 새로
들어오는 수가 자신보다 작을 경우 *최대값이 될 수* 있다. 

* $$m_i$$보다 오른쪽에 위치하고, 자신의 오른쪽에 자신보다 큰 수가 있는 경우

$$m_i$$보다 나중에 윈도우에서 벗어난다고 하더라도, 윈도우 안에 자신보다 큰 수가
항상 존재하므로, 윈도우가 오른쪽으로 이동하여도 *최대값이 될 수 없다*.  


### 더 나은 방법

$$w_i$$의 최대값 $$m_i$$를 알고있는 경우, $$m_{i+1}$$을 구하기 위해 $$w_{i+1}$$의
모든 $$k$$개의 수를 비교하는 것이 아닌 *최대값이 될 수 있는 숫자*(위 두 번째 경우)만
비교함으로써, $$m_{i+1}$$ 계산의 시간복잡도를 낮출 수 있다.

이 방법은 각 윈도우에서 *최대값이 될 수 있는 숫자*들을 별도의 자료구조에 담아두고,
윈도우가 이동하면서 새로 들어오는 수를 이 숫자들에 대해서만 대소 비교를 함으로써
가능하다.

덱(deque)을 이용하여 아래와 같은 방법으로 구현할 수 있다.

```
0. 0번째부터 k-2번째까지의 숫자 중 가장 큰 값을 덱에 넣는다.(초기화)
1. k-1번째부터 n-1번째까지 순회하며 i번째 숫자에 대해 아래 과정을 반복한다.
   1-1. 덱의 뒷부분부터 i번째보다 작은 수를 pop()한다.(pop()된 숫자 관점에서 i는 자신의 오른쪽에 위치한 자신보다 큰 수임)
   1-2. 덱의 가장 뒷 부분에 i번째 수를 넣는다. 
   1-3. 덱의 0번째 수를 출력한다.(0번째 수는 현재 윈도우의 최대값)

```






