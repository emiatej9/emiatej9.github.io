---
layout: page
title:  Sliding Window Maximum
tags: [LeetCode, Deque]
---

주어진 배열 nums에 대해, 왼쪽에서 오른쪽으로 움직이는 크기 k의 윈도우가 있다.<br>
윈도우를 오른쪽으로 한 자리씩 이동하면서 윈도우에 포함되는 k개의 숫자 중 최대값을 출력하시오.  
<a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank">
    LeetCode 문제 바로가기
</a>


예시:
```
Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
Output: [3,3,5,5,6,7] 
Explanation: 

Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

## 풀이
---
### 문제정의

길이가 k인 윈도우는 연속된 k개의 숫자로 생각할 수 있다. 
따라서 i번째 윈도우($$w_i$$)를 다음과 같이 정의해보자.

$$w_i = \{a_i, a_{i+1}, a_{i+2}, ..., a_{i+k-1} \}$$

그리고 i번째 윈도우($$w_i$$)에서 가장 큰 수를 $$m_i$$ 라고 할 때,

$$
m_i = max(w_i) = max(\{a_i, a_{i+1}, a_{i+2}, ..., a_{i+k-1} \})
$$

이다(시간복잡도 $$O(k)$$). 따라서 이 문제는 $$m_0, m_1, m_2, ..., m_{n-k+1}$$을 순서대로 출력하는 것과 같다.

### 기본적인 접근방법
이제 윈도우가 오른쪽으로 이동하는 것에 따른 최대값($$m$$) 계산을 생각해보자.
윈도우가 $$w_i$$에서 $$w_{i+1}$$로 이동하면, 가장 왼쪽에 위치한 $$a_i$$는 윈도우에서 벗어나게 되고
새로운 숫자 $$a_{i+k}$$가 윈도우의 오른쪽 맨 끝으로 들어오게 된다.

$$w_i$$에서 벗어나는 수 $$a_i$$가 $$a_i \ne m_i$$라면, 윈도우 $$w_{i+1}$$에도 여전히 $$m_i$$은 포함되므로,
새로 들어오는 값 $$a_{i+k}$$을 제외한 모든 수가 $$m_i$$보다 작다는 것을 이미 알고있다.
따라서 $$a_{i+k}$$와 비교하여 $$m_{i+1}$$을 결정하면 된다.
즉, $$m_{i+1}=max(m_i, a_{i+k})$$이다(시간복잡도 $$O(1)$$).

만약 $$m_i=a_i$$인 경우라면, 윈도우가 오른쪽으로 이동하면서 최대값이 사라지게 되므로
$$m_{i+1}=max(w_{i+1})$$을 다시 계산해야 한다.
기본적으로 $$m_{i+1}$$ 계산은 윈도우 내의 모든 k개의 숫자를 순회하며 일일이 비교해야하기 때문에
$$O(k)$$의 시간복잡도를 갖는다.

하지만 우리는 $$O(k)$$의 $$m_{i+1}$$ 계산 과정을 조금 더 최적화 할 수 있다.


### 최적화
설명을 위해, 윈도우 안의 k개의 숫자들을 3가지 종류로 분류해 보았다.

&nbsp;&nbsp;&nbsp;&nbsp;1. $$w_i$$에서 최대값($$m_i$$)이 되는 수 \\
&nbsp;&nbsp;&nbsp;&nbsp;2. $$w_{i+1}$$를 포함한 이후 윈도우에서 최대값이 될 수 있는 수 \\
&nbsp;&nbsp;&nbsp;&nbsp;3. 1번과 2번이 아닌 나머지 수

#### $$w_i$$에서 최대값($$m_i$$)이 되는 수

앞서 정의를 하였으니, 넘어가도록 하겠다.

2. $$w_{i+1}$$를 포함한 이후 윈도우에서 최대값이 될 수 있는 수
i번째 윈도우 $$w_i$$에서는 최대값이 아닐 지라도, 윈도우가 오른쪽으로 이동하면서
$$m_i$$가 윈도우에 벗어나게 되면 이후 윈도우에 어떤 수들으 포함되는가에 따라 
두 번째로 큰 수도 이후 윈도우에서 가장 큰 수가 될 수도 있다
(이후에 들어오는 값이 두 번째로 큰 수보다 작은 경우).
같은 방식으로 $$w_i$$에서 세 번째로 큰 수도 두 번째로 큰 수가 윈도우에서 빠져나가게 되면,
이후 어떤 수들이 윈도우에 포함되는가에 따라 가장 큰 수가 될 수 있다.









