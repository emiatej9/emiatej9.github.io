---
layout: page
title:  Sliding Window Maximum
tags: [LeetCode, Deque]
---

주어진 배열 nums에 대해, 왼쪽에서 오른쪽으로 움직이는 크기가 k인 윈도우가 있다.
윈도우를 오른쪽으로 한 자리씩 이동하면서 각 윈도우에 해당하는 k개의 숫자 중 
최대값을 출력하시오.<a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank">
(LeetCode 문제 바로가기)</a>


예시:
```
Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
Output: [3,3,5,5,6,7] 
Explanation: 

Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

## 풀이
---
### 문제정의
* 윈도우

주어진 Input의 연속된 부분배열이다.
길이가 k인 윈도우는 연속된 k개의 숫자로 이루어진 부분배열이다.
따라서 $$i$$번째 윈도우 $$w_i$$를 다음과 같이 정의한다.

$$w_i = \{a_i, a_{i+1}, a_{i+2}, ..., a_{i+k-1} \}$$

* 윈도우의 이동

윈도우의 이동은 윈도우 $$w$$의 인덱스 $$i$$가 증가하는 것으로 생각할 수 있다.
윈도우가 $$w_i$$에서 $$w_{i+1}$$로 이동하면, $$w_i$$의 가장 왼쪽 원소 $$a_i$$가
빠지고, 가장 오른쪽에 새 원소 $$a_{i+k}$$가 들어온다.

* 윈도우의 최대값

윈도우 $$w_i$$의 원소 중 최대값 $$m_i$$을 다음과 같이 정의한다. 

$$
\begin{aligned}
m_i &= max(w_i) \\
    &= max(\{a_i, a_{i+1}, a_{i+2}, ..., a_{i+k-1} \})
\end{aligned}
$$

따라서 주어진 문제는 $$m_0, m_1, m_2, ..., m_{n-k+1}$$을 순서대로 출력하는 것과 
같다.


### 기본적인 방법
윈도우 이동에 따른 최대값 $$m$$의 변화를 생각해보자. 윈도우 $$w_i$$의 최대값 
$$m_i$$가 $$m_i \ne a_i$$라면, 즉, $$w_i$$의 최대값이 0번째 원소가 아닌경우, 
윈도우가 $$w_{i+1}$$로 이동하더라도 $$m_i$$는 윈도우 안에 존재하게 된다. 

정의에 따라 $$m_i$$는 $$w_{i+1}$$의 원소 중 새로 들어온 가장 마지막 원소 $$a_{i+k}$$를 제외한
모든 원소보다 여전히 크므로, 마지막 원소 $$a_{i+k}$$와 비교를 통해 $$w_{i+1}$$의
최대값 $$m_{i+1}$$을 결정할 수 있다.

반면, $$m_i=a_i$$라면 $$w_{i+1}$$에서는 더 이상 $$m_i$$가 존재하지 않기 때문에, $$w_{i+1}$$
모든 원소를 비교하여 $$m_{i+1}$$을 결정해야 한다.  

따라서 이 방법은 최악의 경우에 윈도우가 이동할 때마다 매번 k개의 원소를 비교해야
하므로 시간복잡도 $$O(n^2)$$를 갖는다.


### 개선된 방법
다음 윈도우의 최대값을 찾기 위해 k개의 원소를 모두 비교하지 않고, 최대값이 될
수 있는 원소들만 비교할 수 있을까? 먼저 최대값이 될 수 ***없는*** 원소들을 생각해보자.

임의의 윈도우 안에서, 

* 최대값 왼쪽의 원소는 최대값보다 먼저 윈도우에서 제외되므로 최대값이 될 수 없다.  
* 최대값 오른쪽에 있으나 자신의 오른쪽에 자신보다 큰 원소가 있는 경우 최대값이 될 수 없다.

최대값이 될 수 ***있는*** 원소는 나머지의 경우이다. 임의의 윈도우 안에서,

* 최대값 오른쪽에 있으면서 자신의 오른쪽에 자신보다 작은 원소만 있는 경우

자신의 왼쪽에 있는, 자신보다 큰 원소들이 윈도우의 이동에 따라 윈도우에서 제외되면
최대값이 될 수 ***있다***. 

이렇게 최대값이 될 수 ***있는*** 원소들을 윈도우마다 저장하고, 업데이트 할 수 
있다면 새로운 최대값을 찾기 위해 모든 원소를 비교할 필요가 없다.  


### 최대값이 될 수 있는 원소들의 저장과 업데이트

자료구조 덱(deque)를 이용하여 최대값이 될 수 있는 원소들을 윈도우마다 쉽게 
저장 및 업데이트 할 수 있다. 덱은 양쪽 끝에서 삽입과 삭제가 모두 가능한 자료구조이다.

주어진 입력 배열을 차례대로 순회하면서 현재 윈도우에 해당하는 i번째 원소를 덱에 삽입하되,
아래의 절차를 따른다.

1. 덱의 0번째 원소가 현재 윈도우에 해당하지 않는다면 pop_front()한다.
2. 뒤에서부터 i번째 원소보다 작은 원소가 있으면 pop_back()한다.
3. 뒷부분에 i번째 원소를 push_back()한다.

3가지 절차를 통해, 현재 윈도우의 최대값이 될 수 있는 원소를 저장할 수 있으며, 
0번째 원소는 현재 윈도우의 최대값이 된다.

각 과정을 조금 더 자세히 살펴보도록 하자.

1. 윈도우가 한 칸씩 오른쪽으로 이동하면서, 윈도우에서 가장 왼쪽 원소가 다음 윈도우에서
벗어나게 된다. 3번 과정에 따라, 삽입된 원소는 항상 마지막 인덱스 위치하기 때문에
0번째 원소가 가장 먼저 들어온 원소이고 마지막 원소가 가장 늦게 들어온 원소가 된다.
따라서, 0번째 원소만 현재 윈도우에 해당하는지 검사하면 나머지 원소는 검사할 필요가 없다.    
2. 앞 부분에서 최대값이 될 수 ***없는*** 원소에 대해 설명하였다. 2번은 최대값이
될 수 ***없는*** 원소들을 제거하는 과정이다. i번째 원소보다 작은 원소는 윈도우 안에서
오른쪽에 자신보다 큰 원소 i가 있다는 것을 의미하기 때문에 최대값이 될 수 ***없다***.
3. 최대값이 될 수 ***있는*** 원소를 삽입하는 과정이다. i번째 원소보다 작은 원소는 2번
과정에서 모두 pop_back() 되었으므로, 덱에서 i번째 원소의 앞에는 i번째 원소보다
큰 원소만 남게된다(뒤에는 아직 삽입된 원소가 없다). 다음 윈도우로 이동할 때, 새로 들어오는
원소가 i번째 원소보다 작다면 i번째 원소는 덱에 남아있게 될 것이고, 뒤에는 자기보다 작은
i+1번째 원소가 있게 된다. 이런식으로 덱의 원소들은 내림차순으로 정렬이 되기 때문에
0번째 원소는 현재 윈도우에서 가장 큰 값, 즉, 최대값이 된다.


### 개선된 방법의 구현




