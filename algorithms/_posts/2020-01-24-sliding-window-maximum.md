---
layout: page
title:  Sliding Window Maximum
tags: [LeetCode, Deque]
---

주어진 배열 nums에 대해, 왼쪽에서 오른쪽으로 움직이는 크기 k의 윈도우가 있다.<br>
윈도우를 오른쪽으로 한 자리씩 이동하면서 윈도우에 포함되는 k개의 숫자 중 최대값을 출력하시오.  
<a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank">
    LeetCode 문제 바로가기
</a>


예시:
```
Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
Output: [3,3,5,5,6,7] 
Explanation: 

Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

## 풀이

길이가 k인 윈도우는 연속된 k개의 숫자로 생각할 수 있다. 
따라서 i번째 윈도우($$w_i$$)를 다음과 같이 정의해보자.

$$w_i = \{a_i, a_{i+1}, a_{i+2}, ..., a_{i+k-1} \}$$

그리고 i번째 윈도우($$w_i$$)에서 가장 큰 수를 $$m_i$$ 라고 할 때,

$$
m_i = max(w_i) = max(\{a_i, a_{i+1}, a_{i+2}, ..., a_{i+k-1} \})
$$

이다(시간복잡도 $$O(k)$$).
따라서 이 문제는 $$m_0, m_1, m_2, ..., m_{n-k+1}$$을 순서대로 출력하는 것과 같다.


이제 윈도우가 오른쪽으로 이동하는 경우를 생각해보자.
윈도우가 $$w_i$$에서 $$w_{i+1}$$로 이동하면, 가장 왼쪽에 위치한 $$a_i$$는 윈도우에서 벗어나게 되고
새로운 숫자 $$a_{i+k}$$가 윈도우의 오른쪽 맨 끝으로 들어오게 된다.

$$a_i \ne m_i$$라면, 윈도우 $$w_{i+1}$$에도 여전히 $$m_i$$은 존재하고 있으므로,
새로 들어오는 값 $$a_{i+k}$$을 제외한 모든 수가 $$m_i$$보다 작다.
따라서 $$a_{i+k}$$와 비교하여 $$m_{i+1}$$을 결정하면 된다.
즉, $$m_{i+1}=max(m_i, a_{i+k})$$이다(시간복잡도 $$O(1)$$).

만약 $$m_i=a_i$$인 경우라면, 윈도우가 오른쪽으로 이동하면서 최대값이 사라지게 되므로
$$m_{i+1}=max(w_{i+1})$$을 다시 계산해야 한다(시간복잡도 $$O(k)$$).
하지만 우리가 

